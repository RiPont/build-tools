#!/bin/bash -ex

env

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
. "${SCRIPT_DIR}/../utilities/shell-utils.sh"

chk_set MANIFEST_REPO
chk_set MANIFEST_FILE

# Set and/or error-check build number
if [ ! -z "${BLD_NUM_ARG}" ]; then
    if [ ${BLD_NUM_ARG} -lt 50000 ]; then
        echo "BLD_NUM_ARG must be greater than 50000!"
        exit 1
    else
        BLD_NUM=${BLD_NUM_ARG}
    fi
else
    BLD_NUM=$((BUILD_NUMBER + 50000))
fi

# Read possible Gerrit patches from environment
OPTS=""
if [[ -n $GERRIT_REVIEW_IDS ]]; then
    OPTS+="-r $GERRIT_REVIEW_IDS "
elif [[ -n $GERRIT_CHANGE_IDS ]]; then
    OPTS+="-g $GERRIT_CHANGE_IDS "
elif [[ -n $GERRIT_TOPICS ]]; then
    OPTS+="-t $GERRIT_TOPICS "
fi

MANIFEST_PARAMS="-u ${MANIFEST_REPO} -m ${MANIFEST_FILE}"

rm -rf src
mkdir src
pushd src

# Initial repo sync
echo "Syncing manifest $MANIFEST"
echo ================================
repo init --no-repo-verify --repo-url=ssh://git@github.com/couchbasedeps/git-repo ${MANIFEST_PARAMS} -g all --reference=~/reporef
repo sync --jobs=24 --quiet

# Create build manifest for future reference. Do this before applying
# changes because the local cherry-picked SHAs won't make sense in the
# manifest anyway.
repo manifest -r > manifest.xml

# Have to populate build.properties at the WORKSPACE level
popd

# Generate properties based on manifest - we can use repo's copy of the
# manifest repo
echo "Creating properties files"
echo =========================
"${SCRIPT_DIR}/props-for-manifest" \
    -o build.properties \
    -d src/.repo/manifests \
    -b ${BLD_NUM} \
    ${MANIFEST_FILE}

# Load a few useful params from the properties file.
eval $(sed -e 's/=\(.*\)/="\1"/' build.properties)

# Now save some additional stuff that toy build jobs might need
cat <<EOF >> build.properties
MANIFEST_REPO=${MANIFEST_REPO}
PATCH_VIA_GERRIT_OPTS=${OPTS}
EOF

# And stick the build-properties into git for remote toy builders
if [ ! -d toy-build-manifests ]; then
    git clone ssh://github.com/couchbasebuild/toy-build-manifests
fi
pushd toy-build-manifests
git fetch --all && git reset --hard origin/master
mkdir -p ${PRODUCT_PATH}/${RELEASE}
cp ../build.properties ${PRODUCT_PATH}/${RELEASE}/${VERSION}.properties
cp ../src/manifest.xml ${PRODUCT_PATH}/${RELEASE}/${VERSION}.xml
git add ${PRODUCT_PATH}/${RELEASE}
git commit --allow-empty \
    -m "${PRODUCT} ${RELEASE} build ${VERSION}-${BLD_NUM}" \
    -m "$(date)"
git push origin master
popd

# Back into the repo sync for remaining operations
pushd src

# Apply any changes from Gerrit
if [ ! -z "${OPTS}" ]; then
    echo "Applying changes from Gerrit"
    echo ================================
    "${SCRIPT_DIR}/../utilities/patch_via_gerrit" \
        -d -c ${HOME}/.ssh/patch_via_gerrit.ini \
        ${OPTS} -s .

    # QQQ this should probably parse all <copyfile> and <linkfile> directives
    if [ -f tlm/CMakeLists.txt ]; then
        cp -f tlm/CMakeLists.txt CMakeLists.txt
    fi
fi

# Update any submodules listed in module-projects, if there's a product-config.json to look at
PRODUCT_CONFIG="../manifest/${PRODUCT_PATH}/product-config.json"
if [ -e "${PRODUCT_CONFIG}" ]; then
    for project in $(jq -r '.manifests."'${MANIFEST_FILE}'".module_projects | .[]' "${PRODUCT_CONFIG}"); do
        echo "Updating submodules for ${project}"
        echo ================================
        project_dir=$(repo forall ${project} -c "pwd")
        project_orig_sha=$(repo forall ${project} -c 'echo $REPO_LREV')
        (
            cd ${project_dir}
            # Check out the original revision from the manifest, in case
            # it was overwritten locally by a parent module_project. This
            # roughly maintains the logic of the production builds from
            # update_manifest_from_submodules.
            git checkout ${project_orig_sha}
            git submodule sync --recursive
            git submodule update --init --recursive
        )
    done
fi

if [ "${KEEP_GIT}" = "True" ]; then
    exclude_git_arg=""
    set +x
    # As with build_from_manifest.py, we dereference symlinks in .git
    # directories so they work on Windows.
    echo "Dereferencing .git symlinks"
    echo =======================
    # Make a local temp file
    tempfile=./tmpgitfile
    find . -type l -path '*/.git/*' -print0 | while read -rd $'\0' file; do
        cp -aL "${file}" ${tempfile}
        rm "${file}"
        mv ${tempfile} "${file}"
    done
    set -x
else
    exclude_git_arg="--exclude .repo --exclude-vcs"
fi

echo "Creating source tarball"
echo =======================
tar --create --file ../source.tar.gz --gzip ${exclude_git_arg} .[A-z]* *

# Create final deliverables at WORKSPACE level
popd

cp src/manifest.xml manifest.xml

# Create build-specifically-named versions of the artifacts
# QQQ Not *entirely* sure why we need both of these prefixes
VER_PREFIX="${PROD_NAME}-${VERSION}-${BLD_NUM}"
REL_PREFIX="${PROD_NAME}-${RELEASE}-${BLD_NUM}"
mv source.tar.gz ${VER_PREFIX}-source.tar.gz
mv manifest.xml ${VER_PREFIX}-manifest.xml
# Need to keep original build.properties so Jenkins job can inject it,
# so use cp rather than mv
cp build.properties ${REL_PREFIX}.properties
