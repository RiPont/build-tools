#!/usr/bin/env python3

import argparse
import collections
import dictdiffer
import json
import logging
import os
import pathlib
import re
import requests
import sys
import yaml

from blackduck.HubRestApi import HubInstance
from urllib.parse import urlparse, quote

class UpdateComponents:
    """
    Loads the current set of manually-added components. Given a set of BD manifests,
    applies changes to Black Duck to make the set of manually-added components
    match the manifests.
    """

    # There are two important data structures in this class: comp_map and manifest.
    # comp_map represents the current state in Black Duck (when the program is
    # first run), while manifest represents the desired state as specified by the
    # BD manifests. Both of these structures are in "canonicalized" form, which is
    # a dict.
    #
    # The keys of the dict are Black Duck component IDs; for example,
    # eae20828-18b8-478f-83b3-4a058748a28b is the ID for "fmtlib/fmt".
    #
    #  - for comp_map, these keys will be directly from Black Duck.
    #  - for manifest, these keys will be from the "bd-id" field in the manifest
    #    (preferred). If bd-id is not available, it will be discovered:
    #     - if there is any component in comp_map with the identical bd-name,
    #       use that component's ID
    #     - if no such component exists (ie, this is an entirely new component),
    #       search Black Duck using the REST API for a component matching bd-name
    #       that also has a version matching the first specified version
    #
    #    Searching Black Duck using the REST API is not completely reliable,
    #    so it is encouraged to use the bd-id field in manifests as much as
    #    possible.
    #
    # The values of the dict are dicts with the following entries:
    #    "versions": a Python set of strings, eg. {"7.1.3", "7.1.4"}.
    #    "bd-name": the lowercased name for the component.
    #
    #  - for comp_map, "bd-name" will always be the componentName directly from
    #    Black Duck (lowercased)
    #  - for manifest, "bd-name" will be the "bd-name" field from the manifest
    #    (lowercased) or, if that doesn't exist, the key of the component itself.

    def __init__(self, creds, project, version, dryrun):
        self.dryrun = dryrun
        logging.info(f"Preparing to update components for {project} {version}")
        self.hub = HubInstance(
            creds['url'],
            creds['username'],
            creds['password'],
            insecure=True
        )

        self.comp_base = self.hub.get_apibase() + "/components/"

        # Save Black Duck's data about the project-version
        self.name = f"{project} {version}"
        logging.debug(f"Looking up project {project}")
        self.project = self.hub.get_project_by_name(project)
        logging.debug(f"Looking up project version {version}")
        self.project_version = self.hub.get_version_by_name(self.project, version)

        # Initialize comp_map and manifest schema
        self.manifest = collections.defaultdict(lambda: { "versions": set() })
        self.comp_map = collections.defaultdict(lambda: { "versions": set() })

        # Other globally-used structures, populated or initialized in
        # _load_manual_components() or _load_bd_aliases()
        self.comp_ids = dict()
        self.components = None
        self.bd_comp_id_aliases = {}
        self.bd_comp_version_fallbacks = {}

        # Load BD component alias list
        self._load_bd_aliases()

        # Load all manually-added components currently in Black Duck
        self._load_manual_components()


    def _load_bd_aliases(self):
        """
        Annoyingly, Black Duck component IDs do not seem to be constant.
        Sometimes without warning they can change, or be aliased to another.
        In some cases we can keep track of what it used to be and what it
        reports now, so we can translate the IDs we get from Black Duck to
        the ID in our manifests. It's important that we use the canonical
        ID when calling the REST API, because things such as search filters
        don't work if you use the aliased component ID.

        Also, sometimes we want to use a new component-version that isn't
        in the Black Duck Knowledgebase yet. In that case, we need to keep
        a list of "fallback" versions, which we will use in place of those
        new versions until the new version appears in the Knowledgebase.
        """

        script_dir = pathlib.Path(__file__).resolve().parent
        alias_filepath = script_dir / "bd_aliases.yaml"
        if not alias_filepath.exists():
            return
        with open(alias_filepath) as aliases_file:
            aliases = yaml.safe_load(aliases_file)

        for comp_id, comp_data in aliases.items():
            # Create reverse mapping from alias IDs to canonical ID
            for alias_id in comp_data.get("bd-id-aliases", []):
                self.bd_comp_id_aliases[alias_id] = comp_id

            # Create mapping from <component_id>::<version> to
            # the specified fallback version
            for real_ver, fallback_ver in comp_data.get(
                "fallback-versions", {}
            ).items():
                real_ver = self.canonicalize_version(comp_id, real_ver)
                fallback_ver = self.canonicalize_version(comp_id, fallback_ver)
                key = f"{comp_id}::{real_ver}"
                self.bd_comp_version_fallbacks[key] = fallback_ver

        logging.debug(
            f"Loaded {len(self.bd_comp_id_aliases)} "
            "Black Duck component aliases and "
            f"{len(self.bd_comp_version_fallbacks)} "
            "component fallback versions"
        )


    def _get_version_components(self, projectversion, limit=1000, filters={}):
        """
        Copied from hub-rest-api-python/blackduck/Projects.py so we can add filters
        """

        url = self.hub.get_link(projectversion, "components")
        headers = self.hub.get_headers()
        headers['Accept'] = 'application/vnd.blackducksoftware.bill-of-materials-6+json'
        filter_opts = [ f"{k}:{v}" for k,v in filters.items() ]
        response = requests.get(
            url,
            headers = headers,
            params = { "limit": limit, "filter": filter_opts },
            verify = not self.hub.config['insecure']
        )
        jsondata = response.json()
        return jsondata


    def _load_manual_components(self):
        """
        Reads in set of current manually-added components for project-version and
        store in self.components. Then convert to canonicalized form in self.comp_map.
        Also initialize self.comp_ids.
        """

        # Initialize self.components with report from Black Duck
        logging.debug(f"Retrieving current manual component list for {self.name}")
        self.components = self._get_version_components(
            self.project_version,
            filters = {"bomMatchType": "manually_added"}
        ).get('items', [])
        logging.debug(f"Found {len(self.components)} manual components")

        # Canonicalize component list into comp_map, and populate comp_ids.
        # See top-level comment for discussion of schema of comp_map.
        for comp in self.components:
            comp_url = comp['component']
            comp_id = urlparse(comp_url).path.rsplit('/', 1)[1]
            comp_name = comp['componentName'].lower()
            comp_version_name = self.canonicalize_version(
                comp_name, comp.get('componentVersionName', "")
            )

            self.comp_map[comp_id]["bd-name"] = comp_name
            self.comp_map[comp_id]["versions"].add(comp_version_name)

            # Also canonicalize self.components version names - might be
            # referenced by remove_component() later.
            comp['componentVersionName'] = comp_version_name

            # We also keep a map of lowercased full component names to
            # component ID.
            self.comp_ids[comp_name] = comp_id

        logging.debug(f"Final comp_map: {self.comp_map}")
        logging.debug(f"Final comp_ids: {self.comp_ids}")


    def add_manifest(self, manifest):
        """
        Given the YAML representation of the manifest, store the important
        information internally in canonicalized form
        """

        logging.debug("Canonicalizing manifest")

        try:
            components = manifest['components']
        except KeyError:
            logging.fatal("Manifest does not have top-level 'components' key!")
            sys.exit(2)

        # Canonicalize manifest data into manifest. See top-level comment for
        # discussion of schema of manifest.
        for (comp_name, value) in components.items():
            # Values are dicts with possible keys 'versions', 'bd-id', and
            # 'bd-name'.
            # If the value is instead just an array, it is presumed to be a list of
            # versions, in which case bd-name is just the component name and
            # bd-id is not yet known (set to None).
            if isinstance(value, list):
                versions = value
                comp_lower = comp_name.lower()
                comp_id = None
            else:
                versions = value.get('versions', [])
                comp_lower = value.get('bd-name', comp_name).lower()
                comp_id = value.get('bd-id', None)
                # Translate our manifest component ID to BD alias if necessary
                comp_id = self.bd_comp_id_aliases.get(comp_id, comp_id)

            # If the BD manifest specifies no versions, skip it (probably just
            # there to keep the drift-detector happy).
            if len(versions) == 0:
                continue

            # Canonicalize version names and ensure they're strings (YAML
            # might read them as floats).
            versions = [
                self.canonicalize_version(comp_lower, str(v)) for v in versions
            ]

            # The canonical manifest is keyed by bd-id. If we weren't given
            # the ID here, see if there's a matching full name in comp_ids.
            if comp_id is None:
                comp_id = self.comp_ids.get(comp_lower)

            # If still no ID, do best-effort search in BD Hub, passing in one
            # of the requested versions. This will abort if it fails to find
            # anything, so no need to check the return value.
            if comp_id is None:
                comp_id = self.find_component_by_name(comp_lower, versions[0])

            # Finally, check for fallback versions. Had to wait until now
            # because this process depends on knowing comp_id.
            versions = [
                self.fallback_version_if_necessary(comp_name, comp_id, v)
                for v in versions
            ]

            logging.debug(f"Adding component {comp_lower} ({comp_id}) with versions {versions} to manifest")
            self.manifest[comp_id]["bd-name"] = comp_lower
            self.manifest[comp_id]["versions"].update(versions)


    def canonicalize_version(self, component_name, version):
        """
        Given a version name for a specified component name,
        canonicalize that version name. Normally this is just the
        version name unchanged, but Erlang and Golang have inconsistent
        version naming in the Knowledgebase which leads to false
        matches/misses.
        """

        if component_name.startswith("erlang"):
            return version[4:] if version.startswith("OTP-") else version
        elif component_name.startswith("go programming language"):
            return version[2:] if version.startswith("go") else version
        elif component_name in ("folly", "spdlog"):
            # Quite a few components an have inconsistent "v" at the
            # beginning. It might be worth making it a general
            # canonicalization to strip that, but for now just listing a
            # couple components we know have caused trouble.
            return version[1:] if version.startswith("v") else version
        else:
            return version

    def fallback_version_if_necessary(self, comp_name, comp_id, manifest_ver):
        """
        Given a version name for a specified component, see whether it
        needs to be replaced with a fallback version. This may require
        checking the Knolwedgebase to see whether the specified version
        exists there yet.
        """

        # Does this version have a potential fallback?
        key = f"{comp_id}::{manifest_ver}"
        fallback_ver = self.bd_comp_version_fallbacks.get(key, None)
        if fallback_ver is None:
            # No possible fallback, so no replacement necessary
            return manifest_ver

        # Is the current BOM pointing to the manifest-specified
        # version?
        curr_bom_vers = self.comp_map[comp_id]["versions"]
        if manifest_ver in curr_bom_vers:
            # Yes, BOM is up-to-date with desired version, so no
            # replacement necessary
            return manifest_ver

        # At this point we know the BOM does not reflect the manifest's
        # specified version. It could be a new component-version, or it
        # could be that the BOM is already pointing to a fallback. In
        # either case, we now need to check whether the Knowledgebase
        # knows about the manifest-specified version.
        logging.info(
            f"Version {manifest_ver} of component {comp_name} "
            f"is not in BOM but has potential fallbacks; "
            f"checking Knowledgebase"
        )
        manifest_ver_url = self.find_version_for_component(
            comp_name, comp_id, manifest_ver
        )
        if manifest_ver_url is not None:
            # Yes, the Knowledgebase knows about the desired version!
            # Therefore replacement is NOT necessary; the normal
            # Dictdiffer process will handle the changes later.
            logging.info(
                f"Version {manifest_ver} of component {comp_name} "
                f"found in Knowledgebase! Leaving manifest unchanged."
            )
            return manifest_ver
        else:
            # No, Knowledgebase doesn't know about it yet. So replace
            # the desired version with the fallback version in the
            # canonicalized manifest.
            logging.info(
                f"Version {manifest_ver} of component {comp_name} "
                f"NOT in Knowledgebase; replacing with fallback "
                f"version {fallback_ver}"
            )
            return fallback_ver


    def find_version_for_component(self, component_name, component_id, version):
        """
        Looks up a component in the Knowledgebase via the BD REST API,
        and returns a component_version_url for that component if the
        version is known. Returns None if not found.
        """

        component_url = self.comp_base + component_id

        # Sadly the BD search API doesn't like some legit characters like +, but
        # we can use _ as a single-character wildcard
        safe_version = re.sub(r'[+]', '_', version)
        versions_url = f"{component_url}/versions?q=versionName:{quote(safe_version)}&limit=100"
        logging.debug(f"Searching for version {version} of {component_name}: {versions_url}")
        versions = self.hub.execute_get(versions_url).json().get('items', [])
        logging.debug(f"Found {len(versions)} items")

        # Ensure one of those found versions is an exact match.
        ver_ok = False
        for ver_entry in versions:
            version_name = self.canonicalize_version(
                component_name, ver_entry['versionName']
            )
            if version_name == version:
                return ver_entry['_meta']['href']

        logging.warning(f"Found no matching version!")
        return None


    def find_component_by_name(self, component, version):
        """
        Finds URL for "best" component/version match on Hub - one that
        has an exact match score for the name, and has at least the
        one specified version. This function is vaguely deprecated, but is
        still necessary as a fallback for manifests that don't universally
        use bd-id.
        """

        logging.debug(f"Searching for component {component}")
        hits = self.hub.search_components(component, limit=500).get('items', [{}])[0].get('hits', [])
        logging.debug(f"Found {len(hits)} hits")
        for hit in hits:
            component_name = hit['fields']['name'][0]
            if component_name.lower() != component:
                logging.debug(f"Skipping '{component_name}' because name is not an exact match")
                continue
            score = float(hit['fields']['score'][0])
            if score < 0.8:
                logging.debug(f"Skipping {component_name} because score is too low ({score})")
                continue
            component_url = hit['component']
            component_id = os.path.basename(component_url)
            component_version = self.find_version_for_component(component_name, component_id, version)
            if component_version is None:
                logging.debug(f"Skipping {component_name} because it does not have a version {version}")
                continue
            return urlparse(component_url).path.rsplit('/', 1)[1]
        logging.fatal(f"Found no component-version for {component} {version}!")
        sys.exit(4)


    def add_component(self, comp_id, comp_name, version):
        """
        Adds a component-version to this project-version, which is presumed to
        not already exist. This function may add a fallback version if the
        requested version is not found.
        """

        logging.info(f"Adding component to Black Duck: {comp_name} ({comp_id}) version {version}")
        component_version_url = self.find_version_for_component(
            comp_name, comp_id, version
        )
        if component_version_url is None:
            logging.fatal(f"Could not find version {version} for {comp_name} in Knowledgebase!")
            sys.exit(3)
        logging.debug(f"Component version URL is {component_version_url}")

        pv_components_url = self.hub.get_link(self.project_version, "components")
        if self.dryrun:
            logging.info("DRYRUN: not updating Black Duck")
        else:
            post_data = {'component': component_version_url}
            custom_headers = {'Content-Type': 'application/vnd.blackducksoftware.bomcomponent-1+json', 'Accept': '*/*'}
            response = self.hub.execute_post(pv_components_url, post_data, custom_headers=custom_headers)
            response.raise_for_status()
            logging.debug(f"{comp_id} version {version} added successfully")


    def remove_component(self, comp_id, comp_name, version):
        """
        Removes a component-version from this project-version
        """

        logging.info(f"Removing component: {comp_name} ({comp_id}) version {version}")
        # We need the full URL of "this component-version in this
        # project-version". Conveniently enough those are in the information
        # we initially gathered from Black Duck in self.components, so hunt it
        # down there. It should always be there since by definition we can't
        # be deleting something that didn't exist in the first place. This
        # happens rarely so a simple linear search is fine.
        comp_url = self.comp_base + comp_id
        for component in self.components:
            if (component['component'] == comp_url and
                component.get('componentVersionName', "") == version):
                if self.dryrun:
                    logging.info("DRYRUN: found comp-version but not updating Black Duck")
                else:
                    response = self.hub.execute_delete(component['_meta']['href'])
                    response.raise_for_status()
                    logging.debug(f"{comp_id} version {version} deleted successfully")
                return

        logging.fatal(f"Failed to find component {comp_id} {version} to delete!!")
        sys.exit(1)


    def apply_manifests(self):
        """
        Compute the actions to make self.comp_map look like added manifests,
        then execute each action
        """

        logging.debug("Computing actions")
        diff = dictdiffer.diff(self.comp_map, self.manifest)

        func_map = {
            "add": self.add_component,
            "remove": self.remove_component
        }
        actions_taken = 0

        # dictdiffer gives us a list of diff actions, in a somewhat strange
        # bespoke format. Here we decode them and invoke the corresponding
        # actions.
        for (action, target, value) in diff:
            logging.debug(f"Executing '{action}' '{target}' '{value}'")

            if action == "remove" or action == "add":
                if target == '':
                    # Adding or removing entire components. In this case we
                    # iteratively add/remove each component-version.
                    for (comp_id, data) in value:
                        for version in data["versions"]:
                            func_map[action](comp_id, data["bd-name"], version)
                            actions_taken += 1
                else:
                    # Adding or removing versions from an existing component
                    (comp_id, field) = target.split('.', maxsplit=1)
                    if field != "versions":
                        logging.error(f"Unknown field {field}!")
                        sys.exit(2)
                    # "value" is an array containing 1 tuple.
                    if len(value) != 1:
                        logging.error(f"Too many tuples in {value}!")
                        sys.exit(2)

                    # In this case, comp_id is in both comp_map and manifest,
                    # so we can look up comp_name in either place.
                    comp_name = self.manifest[comp_id]["bd-name"]

                    # The first element in the tuple is always 0 (not
                    # sure why). The second element will be the set of
                    # versions to add/remove.
                    for version in value[0][1]:
                        func_map[action](comp_id, comp_name, version)
                        actions_taken += 1

            elif action == "change" and target.endswith(".bd-name"):
                # Don't care if the bd-name from the manifest doesn't match
                # Black Duck at this point
                logging.debug(f"Ignoring unnecessary change to bd-name")

            else:
                logging.fatal(f"Unknown dictdiffer action {action}!")
                sys.exit(6)

        if actions_taken == 0:
            logging.info("Current components match manifest - no updates needed!")
        else:
            logging.info(f"Updated {actions_taken} components")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Get components from hub"
    )
    parser.add_argument('-d', '--debug', action='store_true',
        help="Produce debugging output")
    parser.add_argument('-c', '--credentials', required=True,
        type=argparse.FileType('r'),
        help="Black Duck Hub credentials JSON file")
    parser.add_argument('-p', '--project', required=True,
        help="project from Black Duck server")
    parser.add_argument('-v', '--version', required=True,
        help="Version of <project>")
    parser.add_argument('-m', '--manifest', required=True, nargs='+',
        type=argparse.FileType('r'),
        help="JSON manifest of manual components")
    parser.add_argument('-n', '--dryrun', action='store_true',
        help="Dry run - don't update Black Duck, just report actions")
    args = parser.parse_args()

    if args.debug:
        log_level = logging.DEBUG
    else:
        log_level = logging.INFO

    logging.basicConfig(
        stream=sys.stderr,
        format='%(threadName)s: %(asctime)s: %(levelname)s: %(message)s',
        level=log_level
    )
    logging.getLogger("requests").setLevel(logging.WARNING)
    logging.getLogger("urllib3").setLevel(logging.WARNING)

    updater = UpdateComponents(
        json.load(args.credentials),
        args.project,
        args.version,
        args.dryrun
    )
    for manifest in args.manifest:
        updater.add_manifest(yaml.safe_load(manifest))
    logging.debug(f"Final input manifest: {updater.manifest}")
    updater.apply_manifests()
